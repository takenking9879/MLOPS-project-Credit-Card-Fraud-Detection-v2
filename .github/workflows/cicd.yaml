name: EKS CI/CD

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'README.md'

permissions:
  id-token: write
  contents: read

jobs:
  integration:
    name: Continuous Integration
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Lint code
        run: echo "Linting repository"

      - name: Run unit tests
        run: echo "Running unit tests"

  deploy:
    name: Deploy to EKS
    needs: integration
    runs-on: ubuntu-latest

    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      EKS_CLUSTER_NAME: ${{ secrets.EKS_CLUSTER_NAME }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Install utilities
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip curl

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: latest

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.14.4

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region "$AWS_REGION" --name "$EKS_CLUSTER_NAME"

      - name: Create namespace
        run: |
          kubectl create namespace mlops-fraud --dry-run=client -o yaml | kubectl apply -f -

      - name: Create env-secret from GitHub Secrets
        run: |
          MLFLOW_S3_BUCKET='${{ secrets.MLFLOW_S3_BUCKET }}'
          MLFLOW_S3_ENDPOINT_URL=""

          kubectl create secret generic env-secret -n mlops-fraud \
            --from-literal=AWS_ACCESS_KEY_ID='${{ secrets.AWS_ACCESS_KEY_ID }}' \
            --from-literal=AWS_SECRET_ACCESS_KEY='${{ secrets.AWS_SECRET_ACCESS_KEY }}' \
            --from-literal=KAFKA_BOOTSTRAP_SERVERS='${{ secrets.KAFKA_BOOTSTRAP_SERVERS }}' \
            --from-literal=KAFKA_USERNAME='${{ secrets.KAFKA_USERNAME }}' \
            --from-literal=KAFKA_PASSWORD='${{ secrets.KAFKA_PASSWORD }}' \
            --from-literal=KAFKA_TOPIC='${{ secrets.KAFKA_TOPIC }}' \
            --from-literal=MLFLOW_S3_BUCKET="$MLFLOW_S3_BUCKET" \
            --from-literal=MLFLOW_S3_ENDPOINT_URL="$MLFLOW_S3_ENDPOINT_URL" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply EFS StorageClass (dynamic provisioning)
        env:
          EFS_FILE_SYSTEM_ID: ${{ secrets.EFS_FILE_SYSTEM_ID }}
        run: |
          sed "s/__EFS_FILE_SYSTEM_ID__/$EFS_FILE_SYSTEM_ID/g" k8s_prod/storageclass-efs.yaml | kubectl apply -f -

      - name: Apply EFS-backed PVCs
        run: |
          kubectl apply -f k8s_prod/airflow/models-pvc.yaml -n mlops-fraud
          kubectl apply -f k8s_prod/inference/spark-checkpoints-pvc.yaml -n mlops-fraud

      - name: Wait for EFS CSI + PVCs
        run: |
          # EFS CSI is installed as an EKS addon by Terraform, but it may take a bit to become ready.
          kubectl -n kube-system rollout status deployment/efs-csi-controller --timeout=10m || true
          kubectl -n kube-system get pods -l app=efs-csi-controller -o wide || true
          kubectl -n kube-system get pods -l app=efs-csi-node -o wide || true

          echo "Waiting for PVCs to be Bound..."
          kubectl -n mlops-fraud wait --for=jsonpath='{.status.phase}'=Bound pvc/models-pvc --timeout=10m
          kubectl -n mlops-fraud wait --for=jsonpath='{.status.phase}'=Bound pvc/spark-checkpoints-pvc --timeout=10m

      - name: Pre-clean stuck secrets (Airflow/MLflow)
        run: |
          set -euo pipefail

          airflow_status=$(helm -n mlops-fraud status my-airflow -o json 2>/dev/null | jq -r '.info.status' || true)
          if [ "$airflow_status" = "failed" ]; then
            echo "Airflow release is failed; deleting known leftover secrets..."
            # Wait for Helm to delete owned resources. Without --wait, the StatefulSet can recreate pods.
            helm -n mlops-fraud uninstall my-airflow --wait --timeout 40s || true

            # Redis is managed by a StatefulSet; deleting the pod alone will just recreate it.
            kubectl -n mlops-fraud scale statefulset/my-airflow-redis --replicas=0 --ignore-not-found
            kubectl -n mlops-fraud delete statefulset my-airflow-redis --ignore-not-found
            kubectl -n mlops-fraud delete pvc redis-db-my-airflow-redis-0 --ignore-not-found
            kubectl -n mlops-fraud delete secret my-airflow-broker-url my-airflow-fernet-key my-airflow-redis-password --ignore-not-found
          else
            echo "Airflow release status: ${airflow_status:-not-installed} (no cleanup)"
          fi

          mlflow_status=$(helm -n mlops-fraud status my-mlflow -o json 2>/dev/null | jq -r '.info.status' || true)
          if [ "$mlflow_status" = "failed" ]; then
            echo "MLflow release is failed; deleting known leftover secret..."
            kubectl -n mlops-fraud delete secret my-mlflow-flask-server-secret-key --ignore-not-found
          else
            echo "MLflow release status: ${mlflow_status:-not-installed} (no cleanup)"
          fi

      - name: Install ingress-nginx
        run: |
          helm upgrade --install ingress-nginx ingress-nginx \
            --repo https://kubernetes.github.io/ingress-nginx \
            --namespace ingress-nginx --create-namespace \
            --wait --timeout 10m

      - name: Wait for ingress-nginx admission webhook
        run: |
          kubectl -n ingress-nginx rollout status deployment/ingress-nginx-controller --timeout=10m

          echo "Waiting for ingress-nginx-controller-admission endpoints..."
          for i in $(seq 1 60); do
            endpoints=$(kubectl -n ingress-nginx get endpoints ingress-nginx-controller-admission -o jsonpath='{.subsets[*].addresses[*].ip}' 2>/dev/null || true)
            if [ -n "$endpoints" ]; then
              echo "Admission endpoints ready: $endpoints"
              exit 0
            fi
            sleep 5
          done

          echo "Timed out waiting for ingress-nginx admission endpoints"
          kubectl -n ingress-nginx get pods -o wide || true
          kubectl -n ingress-nginx describe svc ingress-nginx-controller-admission || true
          kubectl -n ingress-nginx get endpoints ingress-nginx-controller-admission -o yaml || true
          exit 1

      - name: Install ingress rules
        run: |
          helm upgrade --install ingress-rule ./k8s_prod/ingress-rules -n mlops-fraud

      - name: Install PostgreSQL (Bitnami)
        run: |
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm repo update
          helm upgrade --install postgres bitnami/postgresql -n mlops-fraud -f k8s/postgres/postgres_values.yaml \
            --wait --timeout 40s

      - name: Install MLflow (S3)
        run: |
          helm repo add community-charts https://community-charts.github.io/helm-charts
          helm repo update
          sed \
            -e "s/__MLFLOW_S3_BUCKET__/${{ secrets.MLFLOW_S3_BUCKET }}/g" \
            -e "s/__MLFLOW_S3_ACCESS_KEY_ID__/${{ secrets.AWS_ACCESS_KEY_ID }}/g" \
            -e "s/__MLFLOW_S3_SECRET_ACCESS_KEY__/${{ secrets.AWS_SECRET_ACCESS_KEY }}/g" \
            k8s_prod/mlflow/mlflow_values_s3.yaml | \
          helm upgrade --install my-mlflow community-charts/mlflow -n mlops-fraud -f -

      - name: Install Airflow
        run: |
          helm repo add apache-airflow https://airflow.apache.org
          helm repo update
          set +e
          out=$(helm install my-airflow apache-airflow/airflow --namespace mlops-fraud -f k8s_prod/airflow/airflow_values.yaml 2>&1)
          code=$?
          set -e

          if [ $code -ne 0 ]; then
            echo "$out"
            if echo "$out" | grep -q "cannot re-use a name that is still in use"; then
              echo "Release my-airflow already exists; continuing."
              exit 0
            fi
            exit $code
          fi

      - name: Diagnostics (Airflow/Postgres/PVC)
        if: failure()
        run: |
          echo "=== PVCs ==="
          kubectl -n mlops-fraud get pvc -o wide || true

          echo "=== Pods (mlops-fraud) ==="
          kubectl -n mlops-fraud get pods -o wide || true

          echo "=== Events (mlops-fraud) ==="
          kubectl -n mlops-fraud get events --sort-by=.lastTimestamp | tail -n 200 || true

          echo "=== Helm status (airflow/postgres) ==="
          helm -n mlops-fraud status my-airflow || true
          helm -n mlops-fraud status postgres || true

      - name: Apply inference pod
        run: |
          kubectl apply -f k8s_prod/inference/inference_values_gitsync.yaml -n mlops-fraud
